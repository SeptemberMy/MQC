!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!    
!!!!!!!!!!!!!!!==================== OUTPUT =====================!!!!!!!!!!!!!
!!!!!!!!!!!!!                       IO.f90                      !!!!!!!!!!!!!    
!!!! This file includes the IO module (input and output statement).!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!    
!!!! IO contains                                                        !!!!!
!! 1.readinput(inputfpath,kfid,title,ktask,kbastype,basfpath,Natom,coor,KATOM)
!!!! Read INPUT file.
!! 2.readbas(basfpath,Natom,KATOM,Kcenter,Ntype,ngf,gfe,gfc)
!!!! Read basis set file.
!! 3.logo(kfid)
!!!! Output logo to OUPUT.
!! 4.Structure(kfid,natom,Nele,coor,katom)
!!!! Output structure to OUPUT.
!! 5.Basisout(kfid,Natom,nshell,katom,kcenter,gfc,gfe,ntype,ngf,ngfall,&
!!            knbas,kbasst,kbased,kpgfst,kpgfed)
!!!! Output basis set information to OUPUT.
!! 6.Oneintout(kfid,nbasis,methods,methodT,methodV,lprint1e,S,T,V,Hcore)
!!!! Output 1e int to OUPUT.
!! 7.TWOintout(kfid,nbasis,neri,methodERI,lprint2e,ERIall)
!!!! Output 2e int to OUPUT.
!! 8.read2eint(nbasis,neri,ERIall)
!!!! Read 2eint Binary file generated by mqc.
!! 9.readauxbas(basfpath,Natom,KATOM,Kcenter,Ntype,ngf,gfe,gfc)
!!!! Read auxiliary basis set file.
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!        Module IO    !!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      Module IO
            use Init
      contains
!======================================================================!
      subroutine readinput 
        implicit double precision (A-H,O-Z)
         character*80 sym,word,word2
!!!!============================ Input =================================!!!!   
        write(kfid,*)'=======================================&
                  =========================================&
                  =================='
        write(kfid,'(25X,A30)')'```INPUT```'
!!!!!!
        open(unit=kinputfid, file=inputfpath,iostat=ios, status="old")
        if(ios/=0)stop "Failed to open INPUT !!!!!"
!!!  title    
            read(kinputfid,'(A80)')title
            title=adjustl(title)
            title=trim(title)
            write (*,*)title
            write(kfid,*)'Task title:',title    
!!! system
            read(kinputfid,'(A1)',advance='no',iostat=ios)sym  
            if(sym=='!')then 
                read (kinputfid,'(A80)')word
                word=adjustl(word)
                word=trim(word)
                write (*,*)trim(word)
                write(kfid,*)'System type:',word 
            end if   
            if(word=='WINDOWS'.or.word=='windows')then
                ksystem=1
            else if(word=='LINUX'.or.word=='linux')then
                ksystem=2
            end if        
            write (*,*)ksystem   
!!!!
        do while(.True.)
            read(kinputfid,'(A1)',advance='no',iostat=ios)sym
            if(sym=='>')then 
                read (kinputfid,'(A80)')word
                word=adjustl(word)
                word=trim(word)
                write (*,*)trim(word)
                if(word=='END'.or.word=='end')exit
            else if(sym=='#')then
                read (kinputfid,'(A80)')word
                word=adjustl(word)
                word=trim(word)
                write (*,*)trim(word)
            end if
!!!! task and method          
            if(word=='TASK' .or. word=='task')then
                  do while(.True.)
                    read(kinputfid,'(2(A10))')word,word2
                    word=adjustl(word)
                    word=trim(word)   
                    if (word=='END'.or.word=='end')exit                                  
                    if(word=='ENERGY'.or.word=='energy')then
                        write (kfid,*)trim(word)
                        write (kfid,*)trim(word2)
                        ktask=1
                        write (*,*)'Task type',ktask
                    end if
                   if(word2=='HF'.or.word2=='hf')then
                        mhf=1
                   else if(word2=='MP2'.or.word2=='mp2')then
                        mmp=1
                   else if(word2=='MP3'.or.word2=='mp3')then
                        mmp=2
                   else if(word2=='MP2.5'.or.word2=='mp2.5')then
                        mmp=3                       
                   else if(word2=='CCSD'.or.word2=='ccsd')then
                        mcc=1
                   else if(word2=='CCSD(T)'.or.word2=='ccsd(t)')then
                        mcc=2                                            
                   end if                    
                  end do
            end if
!!!! basis            
            if(word=='BASIS' .or. word=='basis')then
                do while(.True.)
                    read(kinputfid,'(80A)')word
                    word=adjustl(word)
                    word=trim(word)     
                    if (word=='END'.or.word=='end')exit
                    write (*,*)'Basis set:',word
                    basisname=word
                    write (*,*)'basis name',basisname 
                    if(ksystem==1)then
                        basisname=adjustl(basisname)
                        basisname=trim(basisname)            
                        basfpath='.\basis\' // basisname                
                    else if(ksystem==2)then    
                        basisname=adjustl(basisname)
                        basisname=trim(basisname)            
                        basfpath='./basis/' // basisname     
                    endif
                    write (*,*)'basis path',basfpath
                end do
            end if      
!!! MOLECULE 
            if(word=='MOLECULE' .or. word=='molecule')then         
                read (kinputfid,*)icharge,ispinm
                read (kinputfid,*)word
                word=adjustl(word)
                word=trim(word)     
                if (word=='END'.or.word=='end')exit                    
                if(word=='ANGSTROM' .or. word=='angstrom')then 
                    isA=1
                else if (word=='BOHR' .or. word=='bohr') then
                    isa=0
                else
                    stop  'Bad INPUT of coordinates units'      
                end if      
                read (kinputfid,*)Natom
                allocate(coor(natom,3),KATOM(natom))
!!!            
                write(kfid,*)'MOLECULE'
                write(kfid,*)' charge:',icharge,' spin multiplicity:',ispinm
                write(kfid,*)' Coordinates (bohr):'
                write(kfid,'(3(24x,1a))')'X','Y','Z'
                do i=1,natom
                    read (kinputfid,*)KATOM(i),coor(i,1),coor(i,2),coor(i,3)
                    write(kfid,*)KATOM(i),coor(i,:)
                end do 
                  read (kinputfid,*)word
                  word=adjustl(word)
                  word=trim(word)   
                  if (word/='END'.and.word/='end')stop 'Number of atom is wrong !!!'                
                if(isA==1)then 
                    coor=coor/BOHR2A
                end if
                write(*,*)KATOM
                write(*,*)coor(:,1)
                write(*,*)coor(:,2)
                write(*,*)coor(:,3)
            end if      
!!!!  INT         
            if(word=='INT' .or. word=='int')then
                do while(.True.)
                    read(kinputfid,*)word
                    word=adjustl(word)
                    word=trim(word)  
                    if (word=='END'.or.word=='end')then
                        exit
                    else if (word=='METHODS'.or.word=='methods')  then
                        backspace(kinputfid)
                        read (kinputfid,*)word,methodS
                        write (*,*)trim(word),methodS 
                    else if (word=='METHODT'.or.word=='methodt')  then
                        backspace(kinputfid)                    
                        read (kinputfid,*)word,MethodT
                        write (*,*)trim(word),MethodT 
                    else if (word=='METHODV'.or.word=='methodv')  then
                        backspace(kinputfid)
                        read (kinputfid,*)word,methodv
                        write (*,*)trim(word),methodv                        
                    else if (word=='METHODERI'.or.word=='methoderi')  then
                        backspace(kinputfid)
                        read (kinputfid,*)word,methodERI
                        write (*,*)trim(word),methodERI
                    else if (word=='LIBCINT'.or.word=='libcint')  then
                        backspace(kinputfid)
                        read (kinputfid,*)word,word2
                        write (*,*)trim(word),trim(word2)  
                        if(word2=='on' .or.word2=='ON')  usecint=.true.
                    end if
                end do
                write (kfid,*)'method_S',methodS
                write (kfid,*)'method_T',methodT
                write (kfid,*)'method_V',methodV
                write (kfid,*)'method_ERI',methodERI                
            end if                    
!!!!    SCF
            if(word=='SCF' .or. word=='scf')then
                do while(.True.)
                  read(kinputfid,*)word
                  word=adjustl(word)
                  word=trim(word)  
                  if (word=='END'.or.word=='end')then
                        exit
                  else if (word=='DAMP' .or. word=='damp')then
                        backspace(kinputfid)
                        read (kinputfid,*)word,damp
                        write (*,*)trim(word),damp
                  else if (word=='MAXCYCLE' .or. word=='maxcycle')then
                        backspace(kinputfid)
                        read (kinputfid,*)word,maxcycle
                        write (*,*)trim(word),maxcycle                      
                  else if (word=='CONVERE' .or. word=='convere')then
                        backspace(kinputfid)
                        read (kinputfid,*)word,conver_E
                        write (*,*)trim(word),conver_E     
                  else if (word=='CONVERRMS' .or. word=='converrms')then
                        backspace(kinputfid)
                        read (kinputfid,*)word,conver_rms
                        write (*,*)trim(word),conver_rms     
                  else if (word=='GUESS' .or. word=='guess')then
                        backspace(kinputfid)
                        read (kinputfid,*)word,mguess
                        write (*,*)trim(word),mguess       
                  else if (word=='DIIS' .or. word=='diis')then
!!!!  mdiis=1,diis on, mdiis=-1,diis off                  
                        backspace(kinputfid)
                        read (kinputfid,*)word,mdiis
                        write (*,*)trim(word),mdiis        
                  else if (word=='NDIIS' .or. word=='ndiis')then
!!!!  The size of DIIS space .            
                        backspace(kinputfid)
                        read (kinputfid,*)word,ndiis
                        write (*,*)trim(word),ndiis                                                                                      
                  end if 
                end do       
            end if     
!!!!  POSTHF
            if(word=='POSTHF' .or. word=='posthf')then
                do while(.True.)
                  read(kinputfid,*)word
                  word=adjustl(word)
                  word=trim(word)  
                  if (word=='END'.or.word=='end')then
                        exit
                  else if (word=='DAMP' .or. word=='damp')then
                        backspace(kinputfid)
                        read (kinputfid,*)word,ccdamp
                        write (*,*)trim(word),ccdamp
                  else if (word=='MAXCYCLE' .or. word=='maxcycle')then
                        backspace(kinputfid)
                        read (kinputfid,*)word,maxcyclecc
                        write (*,*)trim(word),maxcyclecc                           
                  else if (word=='CONVERE' .or. word=='convere')then
                        backspace(kinputfid)
                        read (kinputfid,*)word,conver_Ecc
                        write (*,*)trim(word),conver_Ecc     
                  else if (word=='CONVERRMS' .or. word=='converrms')then
                        backspace(kinputfid)
                        read (kinputfid,*)word,conver_rmscc
                        write (*,*)trim(word),conver_rmscc          
                  else if (word=='CCDIIS' .or. word=='ccdiis')then
!!!!  mdiis=1,diis on, mdiis=-1,diis off                  
                        backspace(kinputfid)
                        read (kinputfid,*)word,mdiiscc
                        write (*,*)trim(word),mdiiscc        
                  else if (word=='CCNDIIS' .or. word=='ccndiis')then
!!!!  The size of DIIS space .            
                        backspace(kinputfid)
                        read (kinputfid,*)word,ndiiscc
                        write (*,*)trim(word),ndiiscc                                                                                      
                  end if 
                end do       
            end if             
!!!!  OUTPUT        
            if(word=='OUTPUT' .or. word=='output')then
                do while(.True.)
                    read(kinputfid,*)word
                    word=adjustl(word)
                    word=trim(word)  
                    if (word=='END'.or.word=='end')then
                        exit
                    else if (word=='XYZFILE'.or.word=='xyzfile')  then
                        backspace(kinputfid)
                        read (kinputfid,*)word,Moutxyzfile
                        write (*,*)trim(word),Moutxyzfile
                   else if (word=='LEVEL'.or.word=='level')  then
                        backspace(kinputfid)
                        read (kinputfid,*)word,Moutlevel
                        write (*,*)trim(word),Moutlevel                        
                    end if
                end do
            end if     
!!!!  PATH        
            if(word=='BASPATH' .or. word=='baspath')then
                do while(.True.)
                    read(kinputfid,*)word
                    word=adjustl(word)
                    word=trim(word)  
                    if (word=='END'.or.word=='end')then
                        exit
                    else if (word=='BASFPATH'.or.word=='basfpath')  then
                        backspace(kinputfid)
                        read (kinputfid,'((A10,A80))')word,basfpath
                        write (*,*)trim(word),': ',basfpath                     
                    end if
                end do
            end if            
!!!!      
        end do                  
!!!! close file       
        close(kinputfid,iostat=ios)
        if(ios/=0)stop "Failed to close INPUT !!!!!"
      end subroutine
!======================================================================!
      subroutine readbas
!!!!  The file can be obtained from the basis set exchange website(https://www.basissetexchange.org/).
!!!!  Gasussian type 
!!!!  Text file without suffix.
!!!!  If someone wants to use user-defined basis set,please follow the Gasussian type and add '****'
!!!!   line above H.
            use Global
            implicit double precision (A-H,O-Z)
            character*2 atomname,strtem,shelltype,strtemold         
            character*2 ::mname(Natom)
            character*2,allocatable::shname(:)
!!!! 
            nshell=0
            ngfall=0
            do i=1,natom
                  mname(i)=atomsym(katom(i))
            end do
            basfpath=adjustl(basfpath)
            basfpath=trim(basfpath)
            ! write(*,*)natom,katom,mname,Ichar('A')
            open(unit=kbasfid, file=basfpath,iostat=ios,form="formatted",status="old")
            if(ios/=0)stop "Failed to open Basis set file !!!!!"
!!!!  read  shell 
            do i=1,size(katom)
                  atomname=mname(i)
                  do while (.true.)
                        strtemold=strtem
                        read(kbasfid,*) strtem
                        if(atomname==strtem .and. strtemold=='**')then 
                        write(*,*)strtem
                        do while (.true.)
                              strtemold=strtem
                              read(kbasfid,*) strtem
                              if (ichar(strtem(1:1))>=65.and.ichar(strtem(1:1))<=90)then
                                    backspace(kbasfid)
                                    strtemold=strtem
                                    read(kbasfid,*) strtem,kngf
                                    if(strtem=='SP')then
                                    kngf=2*kngf
                                    ! nshell=nshell+2
                                    ! ngfall=ngfall+kngf
                                    ! cycle
                                    end if
                                    write(*,*)strtem,kngf
                                    nshell=nshell+1
                                    ngfall=ngfall+kngf
                              else if(strtem=='**') then
                                    exit
                              end if 
                        end do
                        rewind(kbasfid)
                        exit
                        end if
                  end do
            end do   
!!!! read all   
            write(*,*)nshell,ngfall
            allocate(kcenter(nshell),gfc(ngfall),gfe(ngfall),ntype(nshell),ngf(nshell),shname(nshell))
            rewind(kbasfid)
            mshell=0
            do i=1,size(katom)
                  atomname=mname(i)
                  do while (.true.)
                        strtemold=strtem
                        read(kbasfid,*) strtem
                        if(atomname==strtem .and. strtemold=='**')then
                        mshell=mshell+1
                        kcenter(mshell)=i
                        read(kbasfid,*)shname(mshell) ,ngf(mshell)
                        do j=sum(ngf(1:(mshell-1)))+1,sum(ngf(1:mshell))
                              read(kbasfid,*)gfe(j) ,gfc(j)  
                        end do 
!!!!              
                        strtemold=strtem
                        read(kbasfid,*) strtem
                        do while(strtem/='**')
!!!! Ascii:65-90 A-Z
                              if(.not.(ichar(strtem(1:1))>=65.and.ichar(strtem(1:1))<=90))then
                                    read(kbasfid,*) strtem
                                    cycle
                              end if
                              backspace(kbasfid)
                              mshell=mshell+1
                              kcenter(mshell)=i
                              read(kbasfid,*)shname(mshell) ,ngf(mshell)
                              write(*,*)shname(mshell) ,ngf(mshell)
!!!! SP                    
                              if(shname(mshell)=='SP')then
                                    n=ngf(mshell)
                                    ngf(mshell)=2*ngf(mshell)
                                    do j=sum(ngf(1:(mshell-1)))+1,(sum(ngf(1:(mshell)))-n)
                                    read(kbasfid,*)gfe(j),gfc(j),tem 
                                    write(*,*)'tem',tem
                                    
                                    gfe(j+n)=gfe(j)
                                    gfc(j+n)=tem
                                    end do 
                                    strtemold=strtem
                                    read(kbasfid,*) strtem
                                    cycle
                              end if 
!!!!  Not SP                    
                              do j=sum(ngf(1:(mshell-1)))+1,sum(ngf(1:mshell))
                                    read(kbasfid,*)gfe(j) ,gfc(j)  
                              end do 
                              strtemold=strtem
                              read(kbasfid,*) strtem
                        end do 
                        rewind(kbasfid)
                        exit
                        end if
                  end do
            end do  
            do i=1,nshell
                  do j=1,size(typesym)
                  if (shname(i)==typesym(j))Ntype(i)=j
                  end do
            end do
            write(*,*)kcenter
            write(*,*)shname
            write(*,*)ngf
            write(*,'(7(e16.9))')gfe
            write(*,'(7(e16.9))')gfc
!!!!!    
            deallocate(shname)
            close(kbasfid)            
      end subroutine   
!======================================================================!        
      subroutine logo(kfid)
      implicit double precision (A-H,O-Z)
      write(kfid,'(20X,A54)')'******************************************************'
      write(kfid,'(20X,A54)')'***             My Quantum Chemistry               ***'
      write(kfid,'(20X,A54)')'***               version: develop                 ***'
      write(kfid,'(20X,A54)')'***                 Mengyuan Wu                    ***'
      write(kfid,'(20X,A54)')'***  University of Science and Technology Beijing  ***'
      write(kfid,'(20X,A54)')'***       Email: wumengyuan@xs.ustb.edu.cn         ***'
      write(kfid,'(20X,A54)')'******************************************************'
!!!!!!! Symbol
!!!! koala
      write(kfid,'(19X,A10,14X,A7,14x,A10)')  '   /\_/\  '  ,'   *   ','   /\_/\  ' 
      write(kfid,'(19X,A10,14X,A7,14x,A10)')  '  ( o.o ) '  ,'  ***  ','  ( o.o ) '
      write(kfid,'(19X,A10,14X,A7,14x,A10)')  '   > ^ <  '  ,' ***** ','   > ^ <  '  
      write(kfid,'(19X,A10,14X,A7,14x,A10)')  '  /  |  \ '  ,'*******','  /  |  \ '
      write(kfid,'(19X,A10,14X,A7,14x,A10)')  '  /_ | _\ '  ,'  | |  ','  /_ | _\ ' 
      write(kfid,'(20X,A54)')'******************************************************' 
      end subroutine
!======================================================================!
!======================================================================!
      subroutine Structure(kfid,natom,Nele,coor,katom,Moutxyzfile)
            use Global
            implicit double precision (A-H,O-Z)
            dimension::coor(natom,3),katom(natom),coora(natom,3),&
                  R(natom,natom),ex(natom,natom),ey(natom,natom),&
                  ez(natom,natom)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!     

!!!!!!!! Structure
      write(kfid,*)'=======================================&
                  =========================================&
                  =================='
      write(kfid,'(25X,A30)')'```Structure```'
!!! ATOM      
      coora=coor*BOHR2A
      nalpha=(nele+ispinm-1)/2
      nbeta=nele-nalpha
      if(mod((nele+ispinm-1),2)/=0 .or.mod((nele-ispinm+1),2)/=0)then
            write(kfid,*)'Wrong!!! Please check  number of electrons and spin multiplicity'
            write(kfid,*)'Number of electrons: ',nele,'spin multiplicity: ',ispinm
            stop 'The number of electrons and spin multiplicity do not match!!!'
      end if
      if(nalpha/=nbeta) iscloseshell=.false.
      write(kfid,*)'Alpha eletron :',nalpha,'Beta eletron :',nbeta
      if(iscloseshell)then
            write(kfid,*)'Closed shell'
      else
            write(kfid,*)'Open shell'
      end if
      write(kfid,'(A4,/A6,I4,6x,A10,I4,30X,A17)')'ATOM','Natom:',natom,'Nelectron:',&
            nele,'Coordinates(bohr)'
      write(kfid,'(6X,3(A6,3X),3(14X,A4))')'NUB','SYMBAL','NZ','X','Y','Z'
      do i=1,natom
        write(kfid,'(5X,I7,A6,6X,I6,6X,3(F20.12))')i,atomsym(katom(i)),katom(i),coor(i,:)
      end do  
      write(kfid,'(58x,A22)')'Coordinates(Angstroms)'    
      write(kfid,'(6X,3(A6,3X),3(14X,A4))')'NUB','SYMBAL','NZ','X','Y','Z'
      do i=1,natom
        write(kfid,'(5X,I7,A6,6X,I6,6X,3(F20.12))')i,atomsym(katom(i)),katom(i),coora(i,:)
      end do  
!!!!! Output xyz file             
      if(Moutxyzfile==1)then
            kxyzfid=66 
            open (kxyzfid, file = "Structure.xyz",status='replace')   
            write(kxyzfid,*)Natom
            write(kxyzfid,*)'Structure generated by MQC  ','(Angstroms)'
            do i=1,natom
                  write(kxyzfid,'(A6,6X,3(F20.12))')atomsym(katom(i)),coora(i,:)
            end do  
            close(kxyzfid)
      end if           
!!!!!  Interatomic distances and Bond angles
      do i = 1, Natom
            do j=1,Natom
            r(i,j)=sqrt((coor(i,1)-coor(j,1))**2+&
                  (coor(i,2)-coor(j,2))**2+(coor(i,3)-coor(j,3))**2)
            end do
      end do
      write(kfid,*)'------------------------------------& 
                  ---------------------------------------&
                  -----------------------'
      write(kfid,*)'Interatomic Distances'
      write(kfid,'(2(1x,A11),6X,A11,13x,a15)')'i','j','Rij(bohr)','Rij(Angstroms)'
    do i = 1, Natom
            do j=1,i-1
                  write(kfid,*)i,j,r(i,j),r(i,j)*BOHR2A
!!!!! unit vector                  
                  ex(i,j)=-((coor(i,1)-coor(j,1)))/r(i,j)
                  ey(i,j)=-((coor(i,2)-coor(j,2)))/r(i,j)
                  ez(i,j)=-((coor(i,3)-coor(j,3)))/r(i,j)
                  ex(j,i)=-ex(i,j)
                  ey(j,i)=-ey(i,j)
                  ez(j,i)=-ez(i,j)
            end do
      end do
      write(kfid,*)'Interatomic Distances Matrix(Angstroms)'
      ! call outputmatrixd(natom,natom,r*BOHR2A,kfid)
      call outputmatrixd_tri(natom,r*BOHR2A,kfid)
      if(natom>2)then
            write(kfid,*)'------------------------------------& 
                  ---------------------------------------&
                  -----------------------'
            write(kfid,*)'Bond Angles'
            write(kfid,"(3(a12),3(a18,10x))")'i','j','k','angle(Radian)','angle(degrees)'
            bondangle=0d0
            do i = 1, Natom
                  do j=1,i-1
                  do k=1,j-1
                        angpi=cbondangle(natom,R,ex,ey,ez,i,j,k)
                        angdeg=angpi*180d0/pi
                        if(r(i,j)<4d0 .and. r(j,k)<4d0)then
                              write(kfid,*)i,j,k,angpi,angdeg
                        end if
                  end do
                  end do
            end do
      end if
!!!!!  Out-of-Plane Angles
      if(natom>3)then
      write(kfid,*)'------------------------------------& 
                  ---------------------------------------&
                  -----------------------'
      write(kfid,*)'Out-of-Plane Angles'
      write(kfid,"(4(a12),3(a18,10x))")'i','j','k','l','angle(Radian)','angle(degrees)'   
      do i = 1, Natom
       do j=1,Natom
        do k=1,Natom
          do l=1,j-1
          eijklx=0d0
          eijkly=0d0
          eijklz=0d0
            if((i .ne. j) .and. (i .ne. k).and. (i .ne. l).and. (j .ne. k)&
            .and.( l .ne. j) .and.( l .ne. k) .and. (r(i,k)<4d0)&
            .and. (r(j,k)<4d0).and. (r(l,k)<4d0)) then
                  eijklx=(ey(k,j)*ez(k,l)-ez(k,j)*ey(k,l))*ex(k,i)   
                  eijkly=(ez(k,j)*ex(k,l)-ex(k,j)*ez(k,l))*ey(k,i)    
                  eijklz=(ex(k,j)*ey(k,l)-ey(k,j)*ex(k,l))*ez(k,i)    
                  ! eijkl=(eijklx+eijkly+eijklz)/sin(bondangle(j,k,l))
                   eijkl=(eijklx+eijkly+eijklz)/sin(cbondangle(natom,R,ex,ey,ez,l,k,j))
                  oopa=asin(eijkl)
                  if(eijkl<-1d0) oopa=asin(-1d0)
                  if(eijkl>1d0) oopa=asin(1d0)        
                  oopadeg=oopa*180d0/pi
                  write(kfid,*)i,j,k,l,oopa,oopadeg
            end if 
          end do 
         end do
       end do
      end do
!!!!! Dihedral Angles/Torsional Angle  
      write(kfid,*)'Dihedral Angles/Torsional Angle'
      write(kfid,"(4(a12),3(a18,10x))")'i','j','k','l','angle(Radian)','angle(degrees)'   
      do i = 1, Natom
       do j=1,i-1
        do k=1,j-1
          do l=1,k-1
            if((r(i,j)<4d0) .and. (r(j,k)<4d0).and. (r(l,k)<4d0)) then
                  eijjkx=(ey(i,j)*ez(j,k)-ez(i,j)*ey(j,k))   
                  eijjky=(ez(i,j)*ex(j,k)-ex(i,j)*ez(j,k))    
                  eijjkz=(ex(i,j)*ey(j,k)-ey(i,j)*ex(j,k))   
!!!!                  
                  ejkklx=(ey(j,k)*ez(k,l)-ez(j,k)*ey(k,l))   
                  ejkkly=(ez(j,k)*ex(k,l)-ex(j,k)*ez(k,l))    
                  ejkklz=(ex(j,k)*ey(k,l)-ey(j,k)*ex(k,l))                     
                  tijkl=(eijjkx*ejkklx+eijjky*ejkkly+eijjkz*ejkklz)&
                  /sin(cbondangle(natom,R,ex,ey,ez,i,j,k))&
                  /sin(cbondangle(natom,R,ex,ey,ez,j,k,l))
                  da=acos(tijkl)
                  if(tijkl<-1d0) da=acos(-1d0)
                  if(tijkl>1d0) da=acos(1d0)        
                  dadeg=da*180d0/pi
                  write(kfid,*)i,j,k,l,da,dadeg
            end if 
          end do 
         end do
       end do
      end do   
      end if
!!!!
      end subroutine
!!!!!! Compute bond angle
      function cbondangle(natom,R,ex,ey,ez,i,j,k)
            use Global
            implicit double precision (A-H,O-Z)
            dimension:: R(natom,natom),ex(natom,natom),ey(natom,natom),&
                         ez(natom,natom)
!!!!  j  is the central atom    
            cbondangle=acos(ex(j,i)*ex(j,k)+ey(j,i)*ey(j,k)+ez(j,i)*ez(j,k))
      end function   cbondangle     
!======================================================================!
!======================================================================!
      subroutine Basisout(kfid,isaux,Natom,nshell,katom,&
                  kcenter,gfc,gfe,ntype,ngf,ngfall,&
                  knbas,kbasst,kbased,kpgfst,kpgfed,norb)
            use Global
            implicit double precision (A-H,O-Z)
            dimension::kbasst(nshell),kbased(nshell),knbas(nshell),&
                 kpgfst(nshell),kpgfed(nshell),katom(natom)
            dimension::kcenter(nshell),gfc(ngfall),gfe(ngfall),ntype(nshell),ngf(nshell)     
!! BASIS SET
      write(kfid,*)'=======================================&
                  =========================================&
                  =================='
      write(kfid,'(25X,A30)')'```Basis Set```' 
      write(kfid,*)'Basis set:', basisname  
      write(kfid,*)'Basis set file path: ',basfpath  
      write(kfid,*)'------------------------------------& 
                -----------------------------------------&
                ---------------------' 
      write(kfid,'(2(A8,3x),a8,1x,a5,8x,a12,11x,a26)')'center','atom','type','kgf',&
            'Exponent(s)','Contraction coefficient(s)'
!!!!
      do i=1,nshell
            write(kfid,'(i8,5x,A5,5x,A6)')kcenter(i),atomsym(katom(kcenter(i))),typesym(ntype(i))
            do j= 1, ngf(i)
                  kkpgf=kpgfst(i)+j-1
                  write(kfid,'(30x,i5,2(5x,F22.15))')kpgfst(i)+j-1,gfe(kkpgf),gfc(kkpgf)
            end do
      end do     
!!! SHELL
      write(kfid,*)'------------------------------------& 
                -----------------------------------------&
                ------------------------------' 
      write(kfid,'(30X,A5)')'SHELL'  
      write(kfid,'("SHELL:",I4,2x,/,&
                  "BASIS FUNCTION(Cartesian):",I4,2x,/,&
                  "BASIS FUNCTION(Spherical):",I4,2x,/,&
                  "PRIMITIVE GAUSSIAN FUNCTION:",I4)')&
                  nshell,nbasis,norb,sum(ngf(:))  
      write(kfid,'(10(A6,5X))')'NUB','TYPE','TYPSYM','ATOM','Nbas','basst',&
                  'based','NPGF','pgfst','pgfed'       
      do i=1,nshell
            write(kfid,'(I6,5X,I6,5X,A6,7(5X,I6))')i,ntype(i),typesym(ntype(i)),&
                  kcenter(i),knbas(i),kbasst(i),kbased(i),ngf(i),kpgfst(i),kpgfed(i)
      end do          
      end subroutine   
!======================================================================!
!======================================================================!
      subroutine Oneintout(kfid,nbasis,methods,methodT,methodV,lprint1e,&
                        S,T,V,Hcore,dipx,dipy,dipz)
            use Global
            implicit double precision (A-H,O-Z)
            dimension::S(nbasis,nbasis),T(nbasis,nbasis),&
                       V(nbasis,nbasis),Hcore(nbasis,nbasis),&
                       dipx(nbasis,nbasis),dipy(nbasis,nbasis),&
                       dipz(nbasis,nbasis)
!!!!!! Overlap
        write(kfid,*)'------------------------------------& 
                -----------------------------------------&
                -----------------------------------' 
      if (lprint1e==1) then
            write(kfid,'(30X,A30)')'**********************'
            write(kfid,'(30X,A30)')'ONE ELECTRON INTEGRALS'
            write(kfid,'(30X,A30)')'**********************'
        if(usecint)    then
            write(kfid,'(22x,A40)')'S: libcint'
            write(kfid,*)'Overlap    '
            ! call outputmatrixd(nbasis,nbasis,S,kfid)
            call outputmatrixd_tri(nbasis,S,kfid)
            write(kfid,'(22x,A40)')'T: libcint '
            write(kfid,*)'Kinetic   '
            ! call outputmatrixd(nbasis,nbasis,T,kfid)
            call outputmatrixd_tri(nbasis,T,kfid)
            write(kfid,'(22x,A40)')'NAI: libcint '
            write(kfid,*)'NUCLEAR ATTRACTION   '
            ! call outputmatrixd(nbasis,nbasis,V,kfid)
            call outputmatrixd_tri(nbasis,V,kfid)
        else      
            if(methods==1 )then
                  write(kfid,'(30x,A40)')'S: Gauss-Hermite numerical integration'
            else if(methods==2) then
                  write(kfid,'(30x,A40)')'S: Analytical algorithm'
            else
                  write(kfid,'(30x,A40)')'S: Something wrong!!!'
            end if
            write(kfid,*)'Overlap    '
            ! call outputmatrixd(nbasis,nbasis,S,kfid)
            call outputmatrixd_tri(nbasis,S,kfid)
!!!!!! T
            write(kfid,*)'------------------------------------& 
                -----------------------------------------&
                -----------------------------------' 
            if(methodT==1)then 
                  write(kfid,'(22x,A40)')'T: Direct method'
            else if(methodT==2)then 
                  write(kfid,'(22x,A40)')'T: Integral by parts'
            else
                  write(kfid,'(22x,A40)')'T: Something wrong!!!'
            end if
            write(kfid,*)'Kinetic   '
            ! call outputmatrixd(nbasis,nbasis,T,kfid)
            call outputmatrixd_tri(nbasis,T,kfid)
!!!!!! NAI (no symbol)
            write(kfid,*)'------------------------------------& 
                -----------------------------------------&
                -----------------------------------' 
            if(methodV==1)then 
                  write(kfid,'(30x,A40)')'NAI: Analytical algorithm'
            else if(methodV==2) then
                  write(kfid,'(30x,A40)')'NAI: Dupuis-Rys-King Method'
            else if(methodV==3) then
                  write(kfid,'(30x,A40)')'NAI: S.Obara Recursive Method '
            else
                  write(kfid,'(30x,A40)')'NAI: Something wrong!!! '
            end if
            write(kfid,*)'NUCLEAR ATTRACTION   '
            ! call outputmatrixd(nbasis,nbasis,V,kfid)
            call outputmatrixd_tri(nbasis,V,kfid)
         end if !!! uselibcint
!!!!!!  Hcore=T-V        
            write(kfid,*)'------------------------------------& 
                -----------------------------------------&
                -----------------------------------' 
            write(kfid,'(22x,A40)')'Hcore=T-V'
            write(kfid,*)'Core Hamiltonian  '
            ! call outputmatrixd(nbasis,nbasis,Hcore,kfid)
            call outputmatrixd_tri(nbasis,Hcore,kfid)
!!!!! Multipole matrices            
            if(.not. usecint)then
                  write(kfid,*)'------------------------------------& 
                  -----------------------------------------&
                  -----------------------------------' 
                  write(kfid,'(22x,A40)')'Multipole matrices(X)'
                  ! call outputmatrixd(nbasis,nbasis,dipx,kfid)
                  call outputmatrixd_tri(nbasis,dipx,kfid)
                  write(kfid,*)'------------------------------------& 
                  -----------------------------------------&
                  -----------------------------------'             
                  write(kfid,'(22x,A40)')'Multipole matrices(Y)'
                  ! call outputmatrixd(nbasis,nbasis,dipy,kfid)
                  call outputmatrixd_tri(nbasis,dipy,kfid)
                  write(kfid,*)'------------------------------------& 
                  -----------------------------------------&
                  -----------------------------------'             
                  write(kfid,'(22x,A40)')'Multipole matrices(Z)'
                  ! call outputmatrixd(nbasis,nbasis,dipz,kfid)
                  call outputmatrixd_tri(nbasis,dipz,kfid)
            end if
      end if        
      end subroutine    Oneintout
!======================================================================!
!======================================================================!
      subroutine TWOintout(kfid,nbasis,neri,methodERI,lprint2e,&
                        ERIall)
            use Global
            implicit double precision (A-H,O-Z)
            Integer*16 neri
            dimension::ERIall(neri)
!!!!! ERI
!!!!!!!!! lprint2e : 0  not output ERI
!!!!!!!!!!!!!!!!!!!  1  output ERI to  2eint.bin
!!!!!!!!!!!!!!!!!!!  2  output ERI to  2eint.bin and OUTPUT
      write(kfid,*)'------------------------------------& 
                  -----------------------------------------&
                  -----------------------------------'
      write(kfid,'(30X,A30)')'**********************'
      write(kfid,'(30X,A30)')'TWO ELECTRON INTEGRALS'
      write(kfid,'(30X,A30)')'**********************'
      write(kfid,*)'neri(all)=',neri   !! number of stored ERI
      write(kfid,*)'neri(nozero)=' ,count(abs(ERIall)>1d-12) !! number of stored nozero ERI           
      nsize=neri*8
      write(kfid,*)'The storage space of storing ERI  requires approximately ' 
      write(kfid,*) 'size',nsize,'B',nsize/1024**1d0,'Kb',nsize/1024**2d0,'Mb',nsize/1024**3d0,'Gb'       
!!!! output eri   to OUTPUT         
      if (lprint2e==2) then                  
            if(methodERI==1 .OR.methodERI==4 )then 
                  write(kfid,'(23x,A40)')'ERI: Dupuis-Rys-King method '
            else if(methodERI==2) then
                  write(kfid,'(23x,A40)')'ERI: S.Obara Recursive Method '
            else if(methodERI==3) then
                  write(kfid,'(23x,A40)')'ERI: (Analytical method) O.Ohata method '        
            else
                  write(kfid,'(23x,A40)')'ERI: Something wrong !!! '
            end if      
            do ii=1,nbasis
                  do jj=1,ii
                        do kk=1,ii
                              do ll=1,kk
                              ij=iI*(iI+1)/2+jj
                              kl=kk*(kk+1)/2+ll  
                              if(ii<jj .or.kk<ll .or.ij<kl) cycle
                              ijkl=indexeri(ii,jj,kk,ll)
                              ! write(kfid,*)'I=',ii,'J=',jj,'K=',kk,'L=',ll,'ERI=',ERIall(ijkl)
                              if(abs(ERIall(ijkl))>1d-10)then
                                    write(kfid,*)ijkl,'I=',ii,'J=',jj,'K=',kk,'L=',ll,'ERI=',ERIall(ijkl)
                              end if    
                              end do       
                        end do      
                  end do     
            end do                         
      end if  
!!!! output eri to 2eint.bin
      if (lprint2e/=0) then
            open (kerifid, file = "2eint.bin",form='unformatted',iostat=ios,status='replace')
            if(ios/=0)stop "Failed to open INPUT !!!!!"
            write(kerifid)ERIall     
            close(kerifid)
            write(kfid,*)'ERI Eri had been written into binary file ',"2eint.bin"
      end if 
      end subroutine   
!======================================================================!     
      subroutine   read2eint(nbasis,neri,ERIall)
            implicit double precision (A-H,O-Z)
            Integer*16 neri
            dimension::ERIall(neri)
!!!!!           
            open (kerifid, file = "2eint.bin",form='unformatted',iostat=ios,status='old')
            if(ios/=0)stop "Failed to open INPUT !!!!!"
            rewind(kerifid)
            read(kerifid)ERIall   
            !     write(*,*)ERIall(indexeri(20,6,12,12))   
            close(kerifid)
      end subroutine 
!======================================================================!     
!!!!===================================================================!!!!
      subroutine outputtime
            implicit double precision (A-H,O-Z)
!!!!!! Output time to OUTPUT
      write(kfid,*)'=======================================&
                  ========================================='
      write(kfid,'(30x,"*** Total time *** ")')         
      write(kfid,*) 'Start time: ',theDate1(1:4)// '.'//theDate1(5:6)// '.'//&
      theDate1(7:8)// ' '//t1_str(1:2) // ':' // t1_str(3:4) // ':' // t1_str(5:10)          
      write(kfid,*) 'End time:   ',theDate(1:4)// '.'//theDate(5:6)// '.'//&
      theDate(7:8)// ' '//t2_str(1:2) // ':' // t2_str(3:4) // ':' // t2_str(5:10)   
      read(t1_str(1:2),*) t1_realh
      read(t2_str(1:2),*) t2_realh
      read(t1_str(3:4),*) t1_realm
      read(t2_str(3:4),*) t2_realm    
      read(t1_str(5:6),*) t1_reals
      read(t2_str(5:6),*) t2_reals   
      write(kfid,*) 'Wall time :', 3600d0*(t2_realh-t1_realh)+60d0*(t2_realm-t1_realm)+(t2_reals-t1_reals),'s'         
      ! read(t1_str,*) t1_real
      ! read(t2_str,*) t2_real
      ! write(kfid,*) 'Wall time :', 5*(t2_real-t1_real )/3d0,'s'
      write(kfid,*) 'CPU time :', t_end-t_start ,'s'
      write(kfid,*) 'CPU time2 :',(it2-it1)/real(irate),'s'
      write(kfid,*)'------------------------------------& 
                -----------------------------------------' 
      write(kfid,'(20x,50A)')' MQC Program terminated normally !'
      write(kfid,*)'=======================================&
                  ========================================='
!!!!! Output time to OUTPUT done
      write(*,*)'*** OUTPUT done ***'
!!!!! Output time to Screen
      write(*,'(10x,10A)')'```TIME```'
      write(*,*) 'Start time: ',theDate1(1:4)// '.'//theDate1(5:6)// '.'//&
      theDate1(7:8)// ' '//t1_str(1:2) // ':' // t1_str(3:4) // ':' // t1_str(5:10)          
      write(*,*) 'End time:   ',theDate(1:4)// '.'//theDate(5:6)// '.'//&
      theDate(7:8)// ' '//t2_str(1:2) // ':' // t2_str(3:4) // ':' // t2_str(5:10)   
      write(*,*) 'Wall time :', 3600d0*(t2_realh-t1_realh)+60d0*(t2_realm-t1_realm)+(t2_reals-t1_reals) ,'s'
      write(*,*) 'CPU time :', t_end-t_start ,'s'
      write(*,*) 'CPU time2 :',(it2-it1)/real(irate),'s'
      end subroutine outputtime
!!!!===================================================================!!!! 
!!!!===================================================================!!!! 
        subroutine CalEnucre
            use init
            implicit double precision (A-H,O-Z)  
!!! Nuclear repulsion energy
            Enuc=0d0      
            do i=1,natom
                  do j=1,natom
                  if(i==j) cycle
                  Raabb=(coor(i,1)-coor(j,1))**2+(coor(i,2)-coor(j,2))**2+&
                        (coor(i,3)-coor(j,3))**2
                  Enuc=Enuc+0.5d0*katom(i)*KATOM(j)/sqrt(Raabb)
                  end do 
            end do       
            write(kfid,*)'Nuclear repulsion energy (a.u.)'
            write(kfid,*)' Enuc=',Enuc
        end subroutine   CalEnucre 
!!!!===================================================================!!!! 
      function counttime_cputime(t_start)
!!!!!! Count time use cpu_time
            implicit double precision (A-H,O-Z)
            call cpu_time(t_now)
            tto=t_now-t_start
            counttime_cputime=tto
      end function counttime_cputime
!!!!===================================================================!!!! 
      function counttime_sysckock(it1)
            use Global
!!!!!! Count time use system_Clock
            implicit double precision (A-H,O-Z)
            call system_Clock(itnow)
            tto=(itnow-it1)/real(irate)
            counttime_sysckock=tto
      end function counttime_sysckock
!!!!===================================================================!!!!
      end Module IO
!!!!===================================================================!!!! 
!!!!===================================================================!!!! 
!!!!===================================================================!!!! 
!!!!===================================================================!!!! 
!!!! The following is the previous output method that has been 
!!!!            transferred to IO module
!!!!===================================================================!!!! 
! !!!! Basical information  for debug.
!     write(*,*)'nele',nele   !! number of all electrons(colsed shell)
!     write(*,*)'nbasis',nbasis   !! number of all basis function
!     write(*,*)'kbasst',kbasst   !! The  first number of basis function in one shell
!     write(*,*)'kbased',kbased   !! The  last number of basis function in one shell
!     write(*,*)'knbas',knbas     !! number of  basis function in one shell
!     write(*,*)'lgfst',lgfst     !! pgf type first and last number 
!     write(*,*)'lgfed',lgfed     !! s=1,p=2:4,d=5:10... get type (eq:000,100..)
!     write(*,*)'kpgfst',kpgfst   !! pgf first number of shell
!     write(*,*)'kpgfed',kpgfed   !! pgf last number of shell
!     write(*,*)'N:SPDFGHI',nss,nps,NDS,nfs,ngs,nhs,nis,nsp  !! Number of SPDFGHI shell
!     write(*,*)'norb',norb       !! (6D->5D) number of  basis function(Gaussian)
!     write(*,'(A6,3x,4(a6,6x))')'naxyz:','basis','Type x','Type y','Type z'
!     do i=1,nbasis
!         write(*,*)i,naxyz(i),naxyz(i+nbasis),naxyz(i+2*nbasis)
!     end do
!     ! write(*,'(25(I3),/)')naxyz
!     ! write(*,*)'neri=',neri   !! number of stored ERI
!     ! write(*,*)'neri(nozero)=' ,count(abs(ERIall)>1d-12) !! number of stored nozero ERI
!!!
    ! write(kfid,*)'nbasis',nbasis   !! number of all basis function
    ! write(kfid,*)'kbasst',kbasst   !! basis function first number of shell
    ! write(kfid,*)'kbased',kbased   !! basis function last number of shell
    ! write(kfid,*)'knbas',knbas     !! number of  basis function in one shell
    ! write(kfid,*)'lgfst',lgfst     !! pgf type first and last number 
    ! write(kfid,*)'lgfed',lgfed     !! s=1,p=2:4,d=5:10... get type (eq:000,100..)
    ! write(kfid,*)'kpgfst',kpgfst   !! pgf first number of shell
    ! write(kfid,*)'kpgfed',kpgfed   !! pgf last number of shell
    ! write(kfid,*)'N:SPDFGHI',nss,nps,NDS,nfs,ngs,nhs,nis  !! Number of SPDFGHI shell
    ! write(kfid,*)'norb',norb       !! (6D->5D) number of  basis function(Gaussian)
    ! write(kfid,*)'naxyz:'
    ! write(kfid,'(25(I3),/)')naxyz
!!!!!
!         write(kfid,'(20X,A54)')'******************************************************'
!         write(kfid,'(20X,A54)')'***         Museum of Quantum Chemistry            ***'
!         write(kfid,'(20X,A54)')'***                 Mengyuan Wu                    ***'
!         write(kfid,'(20X,A54)')'***  University of Science and Technology Beijing  ***'
!         write(kfid,'(20X,A54)')'***       Email: wumengyuan@xs.ustb.edu.cn         ***'
!         write(kfid,'(20X,A54)')'******************************************************'
! !!!!!!! Symbol
! !!!! koala
!         write(kfid,'(20X,A10,14X,A7,14x,A10)')  '   /\_/\  '  ,'   *   ','   /\_/\  ' 
!         write(kfid,'(20X,A10,14X,A7,14x,A10)')  '  ( o.o ) '  ,'  ***  ','  ( o.o ) '
!         write(kfid,'(20X,A10,14X,A7,14x,A10)')  '   > ^ <  '  ,' ***** ','   > ^ <  '  
!         write(kfid,'(20X,A10,14X,A7,14x,A10)')  '  /  |  \ '  ,'*******','  /  |  \ '
!         write(kfid,'(20X,A10,14X,A7,14x,A10)')  '  /_ | _\ '  ,'  | |  ','  /_ | _\ ' 
!         write(kfid,'(20X,A54)')'******************************************************' 
! !!!!!!!! Structure
!     write(kfid,'(25X,A30)')'```Structure```'
! !!! ATOM    
!     write(kfid,'(A4,/A6,I4,50X,A17)')'ATOM','Natom:',natom,'Coordinates(a.u.)'
!     write(kfid,'(6X,3(A6,3X),3(14X,A4))')'NUB','SYMBAL','NZ','X','Y','Z'
!     do i=1,natom
!         write(kfid,'(5X,I7,A6,6X,I6,6X,3(F20.12))')i,atomsym(katom(i)),katom(i),coor(i,:)
!     end do
! !!! BASIS SET
!     write(kfid,'(A9)')'Basis set' 
!     write(kfid,'(2(A8,3x),a8,1x,a5,8x,a12,11x,a26)')'center','atom','type','kgf','Exponent(s)','Contraction coefficient(s)'
! !!!!
!     do i=1,nshell
!         write(kfid,'(i8,5x,A5,5x,A6)')kcenter(i),atomsym(katom(kcenter(i))),typesym(ntype(i))
!         do j= 1, ngf(i)
!             kkpgf=kpgfst(i)+j-1
!             write(kfid,'(30x,i5,2(5x,F22.15))')kpgfst(i)+j-1,gfe(kkpgf),gfc(kkpgf)
!         end do
!     end do     
! !!! SHELL
!     write(kfid,'(A5,/A6,I4)')'SHELL','Nshell:',nshell   
!     write(kfid,'(6X,10(A6,5X))')'NUB','TYPE','TYPSYM','ATOM','Nbas','basst','based','NPGF','pgfst','pgfed'       
!     do i=1,nshell
!         write(kfid,'(5X,I6,5X,I6,5X,A6,7(5X,I6))')i,ntype(i),typesym(ntype(i)),&
!             kcenter(i),knbas(i),kbasst(i),kbased(i),ngf(i),kpgfst(i),kpgfed(i)
!     end do 
!!!!!!!! Result
    ! write(kfid,'(25X,A30)')'``` Result```'
    ! write(kfid,*)'GAMESS TYPE'
    ! write(kfid,*)'Gaussian TYPE'
    ! write(kfid,*)' Enuc=',Enuc
!!!!!! Overlap
!     if (lprint1e==1) then
!         write(kfid,'(30X,A30)')'**********************'
!         write(kfid,'(30X,A30)')'ONE ELECTRON INTEGRALS'
!         write(kfid,'(30X,A30)')'**********************'
!         if(methods==1)then
!             write(kfid,'(30x,A40)')'S: Gauss-Hermite numerical integration'
!         else if(methods==2) then
!             write(kfid,'(30x,A40)')'S: Analytical algorithm'
!         else
!             write(kfid,'(30x,A40)')'S: Something wrong!!!'
!         end if
!         write(kfid,*)'Overlap    '
!         write(kfid,'(i16,24(i20))')(i,i=1,nbasis)
!         do i=1,nbasis
!                 write(kfid,'(i3,25(e20.9))')i,S(i,:)
!         end do 
! !!!!!! T
!         if(methodT==1)then 
!             write(kfid,'(30x,A40)')'T: +2,0,-2'
!         else if(methodT==2)then 
!             write(kfid,'(30x,A40)')'T: Integral by parts'
!         else
!             write(kfid,'(30x,A40)')'T: Something wrong!!!'
!         end if
!         write(kfid,*)'Kinetic   '
!         write(kfid,'(i16,24(i20))')(i,i=1,nbasis)
!         do i=1,nbasis
!                 write(kfid,'(i3,25(e20.9))')i,T(i,:)
!         end do 
! !!!!!! NAI (no symbol)
!         if(methodV==1)then 
!             write(kfid,'(30x,A40)')'NAI: Analytical algorithm'
!         else if(methodV==2) then
!             write(kfid,'(30x,A40)')'NAI: Recursive Method 1'
!         else if(methodV==3) then
!             write(kfid,'(30x,A40)')'NAI: S.Obara Recursive Method '
!         else
!             write(kfid,'(30x,A40)')'NAI: Something wrong!!! '
!         end if
!         write(kfid,*)'NUCLEAR ATTRACTION   '
!         write(kfid,'(i16,24(i20))')(i,i=1,nbasis)
!         do i=1,nbasis
!                 write(kfid,'(i3,25(e20.9))')i,V(i,:)
!         end do 
!     !!!!!!  Hcore=T-V        
!         write(kfid,'(30x,A40)')'Hcore=T-V'
!         write(kfid,*)'Core Hamiltonian  '
!         write(kfid,'(i16,24(i20))')(i,i=1,nbasis) 
!         do i=1,nbasis
!                 write(kfid,'(i3,25(e20.9))')i,T(i,:)-V(i,:)
!         end do 
!     end if
!!!!! ERI
!     if (lprint2e==1) then
!         write(kfid,'(30X,A30)')'**********************'
!         write(kfid,'(30X,A30)')'TWO ELECTRON INTEGRALS'
!         write(kfid,'(30X,A30)')'**********************'
!         if(methodERI==1)then 
!             write(kfid,'(23x,A40)')'ERI: Dupuis-Rys-King method '
!         else if(methodERI==2) then
!             write(kfid,'(23x,A40)')'ERI: S.Obara Recursive Method '
!         else if(methodERI==3) then
!             write(kfid,'(23x,A40)')'ERI: (Analytical method) O.Ohata method '        
!         else
!             write(kfid,'(23x,A40)')'ERI: Something wrong !!! '
!         end if

! !!!! output eri   
!         do ii=1,nbasis
!             do jj=1,ii
!                 do kk=1,ii
!                     do ll=1,kk
!                         ij=iI*(iI+1)/2+jj
!                         kl=kk*(kk+1)/2+ll  
!                         if(ii<jj .or.kk<ll .or.ij<kl) cycle
!                         ijkl=indexeri(ii,jj,kk,ll)
!                         ! write(kfid,*)'I=',ii,'J=',jj,'K=',kk,'L=',ll,'ERI=',ERIall(ijkl)
!                         if(abs(ERIall(ijkl))/=0d0)then
!                             write(kfid,*)'I=',ii,'J=',jj,'K=',kk,'L=',ll,'ERI=',ERIall(ijkl)
!                         end if    
!                     end do       
!                 end do      
!             end do     
!         end do  
!     end if  
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! !!!! Output time
!     call date_and_time(theDate,t2_str) 
!     call cpu_time(t_end)
!     call system_Clock(it2,irate,icount_max)
!     write(kfid,*) 'Start time: ',theDate1(1:4)// '.'//theDate1(5:6)// '.'//&
!     theDate1(7:8)// ' '//t1_str(1:2) // ':' // t1_str(3:4) // ':' // t1_str(5:10)          
!     write(kfid,*) 'End time:   ',theDate(1:4)// '.'//theDate(5:6)// '.'//&
!     theDate(7:8)// ' '//t2_str(1:2) // ':' // t2_str(3:4) // ':' // t2_str(5:10)   
!     read(t1_str,*) t1_real
!     read(t2_str,*) t2_real
!     write(kfid,*) 'Wall time :', t2_real-t1_real ,'s'
!     write(kfid,*) 'CPU time :', t_end-t_start ,'s'
!     write(kfid,*) 'CPU time2 :',(it2-it1)/real(irate),'s'
!     write(*,*)'*** OUTPUT done ***'
! !!
!     write(*,'(10x,10A)')'```TIME```'
!     write(*,*) 'Start time: ',theDate1(1:4)// '.'//theDate1(5:6)// '.'//&
!     theDate1(7:8)// ' '//t1_str(1:2) // ':' // t1_str(3:4) // ':' // t1_str(5:10)          
!     write(*,*) 'End time:   ',theDate(1:4)// '.'//theDate(5:6)// '.'//&
!     theDate(7:8)// ' '//t2_str(1:2) // ':' // t2_str(3:4) // ':' // t2_str(5:10)   
!     write(*,*) 'Wall time :', t2_real-t1_real ,'s'
!     write(*,*) 'CPU time :', t_end-t_start ,'s'
!     write(*,*) 'CPU time2 :',(it2-it1)/real(irate),'s'